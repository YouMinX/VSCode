## 按位操作

![](/notes/408/images-1/2025-07-31-22-05-54.png)

```
unsigned char a = 0b10101100; // 172
unsigned char b = 0b11000011; // 195

a & b // 0b10000000 128
a | b // 0b11101111 239
a ^ b // 0b01101111 111
~a // 0b01010011 83 (按位取反)
a << 2 // 0b10110000 176
a >> 2 // 0b00101011 43
```

### 等待队列

mod
数组 A[21]
递归的详细定义

在 C 语言中，函数参数的`*`和`&`以及`**`的使用是理解指针的关键。以下是详细说明：

---

### 1. **带`*`和不带`*`的参数区别**

- **不带`*`（传值）**：

  ```c
  void func(int a);
  ```

  - 传递的是变量的**副本**，修改形参`a`不会影响实参。
  - 适用于基本数据类型（如`int`、`char`等）或不需要修改实参的场景。

- **带`*`（传指针）**：
  ```c
  void func(int *a);
  ```
  - 传递的是变量的**地址**，通过解引用（`*a`）可以直接修改实参的值。
  - 适用于需要修改实参或传递大型结构体（避免拷贝开销）的场景。

---

### 2. **`**p`（双指针）的含义\*\*

- `**p`是指向指针的指针，常用于：
  - 动态二维数组。
  - 需要修改指针本身（而不仅是指针指向的值）的场景。

**示例**：

```c
void allocate(int **p) {
    *p = malloc(sizeof(int)); // 修改指针本身
    **p = 42;                 // 修改指针指向的值
}
int main() {
    int *ptr;
    allocate(&ptr); // 传递指针的地址
    printf("%d\n", *ptr); // 输出42
    free(ptr);
}
```

---

### 3. **形参中`&p`和`*p`的区别**

- **`&p`**：

  - 是取地址操作，用于获取变量`p`的地址。
  - 在函数调用时，`&p`将变量`p`的地址传递给形参（要求形参是指针类型）。

  ```c
  int a = 10;
  func(&a); // 传递a的地址
  ```

- **`*p`**：
  - 是解引用操作，用于访问指针`p`指向的值。
  - 在函数形参中，`*p`表示参数是一个指针类型。
  ```c
  void func(int *p) {
      *p = 20; // 修改p指向的值
  }
  ```

---

### 4. **关键区别总结**

| 语法      | 含义                     | 用途                             |
| --------- | ------------------------ | -------------------------------- |
| `int p`   | 普通变量（传值）         | 不需要修改实参时使用             |
| `int *p`  | 指针（传地址）           | 需要修改实参或传递大型数据时使用 |
| `int **p` | 指向指针的指针（双指针） | 需要修改指针本身时使用           |
| `&p`      | 取地址操作               | 将变量的地址传递给指针形参       |
| `*p`      | 解引用操作               | 访问或修改指针指向的值           |

---

### 示例代码

```c
#include <stdio.h>

// 修改指针指向的值
void changeValue(int *p) {
    *p = 100;
}

// 修改指针本身（需双指针）
void changePointer(int **p) {
    *p = malloc(sizeof(int));
    **p = 200;
}

int main() {
    int a = 10;
    int *ptr = &a;

    changeValue(ptr);      // 修改a的值
    printf("%d\n", a);     // 输出100

    changePointer(&ptr);   // 修改ptr指向的新内存
    printf("%d\n", *ptr);  // 输出200
    free(ptr);

    return 0;
}
```

通过理解这些概念，可以更灵活地使用指针和参数传递机制。
